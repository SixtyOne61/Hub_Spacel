TO DO

Use xml for create map / module

voir pour spawn les environnement manager dans la map en editor pour gagner du temps sur le loading

Utiliser un character à la place d'un pawn, 
setup le character movement
mettre comme static mesh la base du vaisseau (la partie rouge, qui est indestructible)

Clean BP_SpaceShip not use
Clean Hub_Pawn not use

Add weapon


Clean AProceduralActor with child class not use

Make tuto for use aws for dedicated server : https://www.youtube.com/watch?v=QHB1H6eM-vc
Make tuto for create a server queue system : https://www.youtube.com/watch?v=u2Si2y2hviA

Tuto long mais qui gére tout ce qu'on voudrait faire en multi : https://www.youtube.com/watch?v=tOy0xYaP3wA

Interface du jeu - Main menu; avec "My story" qui est une timeline, join server qui sera fait, 
création du vaisseau par défaut.
Remplissage des équipes automatique
Arriver sur un server, interface avec visionnage de son équipe, changement de son vaisseau
Après 30s, démarrage d'une partie
Durée d'une partie de 10 min
Ecran de fin
Retour au main menu

Use "ConstructionScript" of pawn, only for editor, for create ship in editor

Backlog :
add rotation on UShipPawnMovement
shield gameplay / self shield
smart rocket gameplay / ray gun
iem gameplay (fx carré de perte de controle, la couleur du carré est celle de l'équipe) / furtivité
define rules for create ship module
give life gameplay / repair gameplay
collecte ressource / create ressource on map
map limitation
volumetric cloud




Create xml file :
// create xml file
FXmlFile file;
file.LoadFile("<root>\n</root>", EConstructMethod::ConstructFromBuffer);
// root node
FXmlNode * node = file.GetRootNode();
FString content = "\n";

 FString xml;

    xml = "<location id=\"" + FString::FromInt(m_id) + "\" center=\"" + m_center.ToString() + "\" size=\"" + m_size.ToString() + "\">";
    for (auto const& pair : m_neighbor)
    {
        xml.Append("\n<face type=\"" + FString::FromInt((int)pair.Key) + "\" id=\"" + FString::FromInt(pair.Value->getId()) + "\"/>");
    }
    xml.Append("\n</location>");
	
	
node->AppendChildNode(FString::FromInt(idMesh), content);


bool isGold = UGameplayStatics::GetCurrentLevelName(this->GetWorld()).Contains("InGameLevel");
FString path = FPaths::ProjectDir() + (isGold ? "Content/Xml/Gold/" : "Content/Xml/Test/") + this->GetActorLocation().ToString() + ".xml";
file.Save(path);





Read Xml :
bool AEnvironmentManager::readXml()
{
    bool isGold = UGameplayStatics::GetCurrentLevelName(this->GetWorld()).Contains("InGameLevel");
    FString path = FPaths::ProjectDir() + (isGold ? "Content/Xml/Gold/" : "Content/Xml/Test/") + this->GetActorLocation().ToString() + ".xml";

    FXmlFile file;
    if (!file.LoadFile(path))
    {
        return false;
    }

    FXmlNode * rootNode = file.GetRootNode();
    if (rootNode == nullptr)
    {
        return false;
    }

    TArray<FXmlNode*> const& childrenMesh = rootNode->GetChildrenNodes();
    for (auto * nodeMesh : childrenMesh)
    {
        // node contain all information for one mesh
        if (nodeMesh == nullptr)
        {
            continue;
        }

        TArray<FXmlNode*> const& childrenLocation = nodeMesh->GetChildrenNodes();
        for (auto * nodeLocation : childrenLocation)
        {
            if (nodeLocation == nullptr)
            {
                continue;
            }

            int id = FCString::Atoi(*(nodeLocation->GetAttribute("id")));
            FVector center = FVector::ZeroVector, size = FVector::ZeroVector;
            center.InitFromString(nodeLocation->GetAttribute("center"));
            size.InitFromString(nodeLocation->GetAttribute("size"));

            // TO DO : add neighboor
            m_currentObject.Add(MakeShareable(new ChainedLocation(center, size, id)));
        }

        createProceduralMeshComponent();
    }

    return true;
}
		